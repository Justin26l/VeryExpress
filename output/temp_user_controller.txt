
    public async getListUser(req: Request, res: Response): Promise<Response> {
        try {
          console.log("req.query",req.query);
            const validationError = validationResult(req);
            if ( ! validationError.isEmpty() ) {
                return vex.response.send(res, 400, vex.responseMsg.validateError, validationError.array());
            };
            
            const searchFilter = new MongoQS().parse(req.query);
            let selectedFields : {[key: string]: number} | undefined = undefined;

            try { 
                selectedFields = vex.common.parseFieldsSelect(req.query.select || '');
            } 
            catch (err:any) { 
                return vex.response.send(res, 400, vex.responseMsg.queryError, { error: err.message });
            };


            // if found array "join" in query string, parse it to populate options
            const joinArr = typeof req.query.joinArr == "string" ? JSON.parse(req.query.joinArr) : [];
            const populateOptions : any = [];

            // switch joinArr's item to populate options
            if(joinArr.length > 0) {
              console.log("joinArr",joinArr);
              joinArr.forEach((refKey: any) => {
                const availablePopulateOptions: {[key:string]: string} = {
                  'Package': "name period price startDate endDate",
                  'UserContact': "phoneNo isActive"
                };

                if(availablePopulateOptions[refKey]) {
                  populateOptions.push({
                    path: refKey,
                    select: availablePopulateOptions[refKey],
                    options: { lean: true }
                  })
                };
              });
              console.log("populateOptions",populateOptions);
            }

            const result = await UserModel.find(searchFilter, selectedFields).populate(populateOptions);
                return vex.response.send(res, 200, vex.responseMsg.ok, result);
        } catch (err:any) {
            return vex.response.send(res, 500, vex.responseMsg.unexpectedError, { error: err.message });
        }
    }
