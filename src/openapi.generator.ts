import json2openapi from "json-schema-to-openapi-schema";
import yaml from "js-yaml";
import fs from "fs";

import * as types from './types/types';
import * as openapiType from './types/openapi';
import utils from "./utils";

export function compile(schemaDir: string, outDir: string) :void {

    // convert to yaml
    let openapiJson : openapiType.openapi = {
        openapi: "3.0.0",
        info: {
            title: "veryExpress generated api server",
            description: "OpenApi Spec generated by veryExpress",
            version: "1.0.0"
        },
        paths: {},
        components: {
            schemas: {},
        },
    };
        
    // loop through all json schema files and compile to path object
    let componentSchema: openapiType.components['schemas'] = {};

    // make components
    const files = fs.readdirSync(schemaDir);
    files.forEach((file) => {
        console.log(`[Processing] - OpenApi Generator : ${schemaDir+'/'+file}`);
        const jsonSchemaBuffer = fs.readFileSync(`${schemaDir}/${file}`);
        const jsonSchema :types.jsonSchema = JSON.parse(jsonSchemaBuffer.toString());
        openapiJson = jsonToOpenapiPath(openapiJson, jsonSchema);
        openapiJson = jsonToOpenapiComponentSchema(openapiJson, jsonSchema);
    });

    const validOpenApi = json2openapi(openapiJson, { version: 3.0 });
    const openapiYaml = yaml.dump(validOpenApi);

    // create and write file
    const outputPath = `${outDir}/openapi.yaml`;
    fs.writeFileSync(outputPath, openapiYaml);
};

export function jsonToOpenapiPath(
    openapiJson: openapiType.openapi,
    jsonSchema: types.jsonSchema,
): openapiType.openapi
{
    // get jsonschema properties
    const documentConfig = jsonSchema["x-documentConfig"];
    const docName = documentConfig.documentName;
    const lowerDocName = docName.toLowerCase();
    const camelDocName = docName.charAt(0).toUpperCase() + docName.slice(1);

    const properties = jsonSchema.properties;
    const methods: types.method[] = documentConfig.method;

    let routes: {
        [key: string]: { // route name
            [key: string]: openapiType.method 
        }
    } = {
        ['/'+lowerDocName]: {},
        ['/'+lowerDocName+'/{id}']: {},
    };

    methods.forEach((method) => {
        const useId :boolean = ['put', 'patch', 'delete'].includes(method);
        const useBody :boolean = ['post', 'put', 'patch'].includes(method);
        const route :string = '/'+lowerDocName + ( useId ?'/{id}' : '');

        routes[route][method] = {
            summary: `${method} ${documentConfig.documentName}`,
            operationId: method + lowerDocName,
            tags: [lowerDocName],
            parameters: [],
            requestBody: undefined,
            responses: {
                200: {
                    description: 'OK',
                    content: { 
                        'application/json': { schema: { $ref: `#/components/schemas/${method}${camelDocName}Response` } },
                    },
                },
                400: { description: 'Bad Request', },
                401: { description: 'Unauthorized', },
                403: { description: 'Forbidden', },
                404: { description: 'Not Found', },
                405: { description: 'Method Not Allowed', },
                413: { description: 'Payload Too Large', },
                429: { description: 'Too Many Requests', },
                500: { description: 'Internal Server Error', },
                502: { description: 'Bad Gateway', },
                503: { description: 'Service Unavailable', },
            },
        };

        // update parameters/body & responses

        if( (useId || method == 'get') && properties['_id']){
            const idParameter : openapiType.parameter = {
                name: 'id',
                in: 'path',
                description: properties['_id'].description,
                required: true,
                schema: { type: properties['_id'].type, format: properties['_id'].format },
            };

            routes[route][method].parameters = [idParameter];

            // GET will have additional route of GET /{id}
            if(method == 'get'){
                routes[route+'/{id}'][method] = routes[route][method];
                // @ts-ignore
                routes[route+'/{id}'][method].responses[200].content["application/json"].schema.$ref = `#/components/schemas/${method}${camelDocName}Response`;
                routes[route+'/{id}'][method].parameters = [idParameter];
            };
        };

        if(useBody){
            routes[route][method].requestBody = {
                description: `${method} ${documentConfig.documentName}`,
                required: false,
                content: {
                    'application/json': { schema: { $ref: `#/components/schemas/${method}${camelDocName}Body` } },
                },
            };
        };

        // POST will use 201 success response
        if (method == 'post') {
            routes[route][method].responses[201] = routes[route][method].responses[200];
            routes[route][method].responses[201].description = 'Crerated';
            delete routes[route][method].responses[200];
        }
        else if (method == 'delete') {
            delete routes[route][method].responses[200].content;
        };

    });

    openapiJson.paths = Object.assign(openapiJson.paths, routes);
    return openapiJson;
};

export function jsonToOpenapiComponentSchema(
    openapiJson: openapiType.openapi,
    jsonSchema: types.jsonSchema,
): openapiType.openapi
{
    let parameters: openapiType.parameter[] = [];
    let componentSchemaPath: openapiType.components['schemas'] = {};

    // get jsonschema properties
    const docName = jsonSchema["x-documentConfig"].documentName;
    const camelDocName = docName.charAt(0).toUpperCase() + docName.slice(1);
    const methods: types.method[] = jsonSchema["x-documentConfig"].method;

    const componentSchemaResponse : openapiType.componentsSchemaValue = {
        type: 'object',
        properties: json2openapi(
            utils.cleanXcustomValue(jsonSchema.properties, ['index', 'unique', 'required']), 
            { version: 3.0 }
        ),
    };
    
    const componentSchemaBody : openapiType.componentsSchemaValue = {
        type: 'object',
        properties: json2openapi(
            utils.cleanXcustomValue(jsonSchema.properties, ['_id', 'index', 'unique', 'required']), 
            { version: 3.0 }
        ),
    };


    methods.forEach((method) => {
        switch (method) {
            case 'delete':
                // no param, no response
                break;
            case 'get':
                let params : openapiType.parameter[] = [];
                Object.keys(jsonSchema.properties).forEach((key)=>{
                    const props = jsonSchema.properties[key];
                    
                    // skip object, obj should not be in query
                    if(props.type == 'object') return;

                    params.push({
                        "name": key,
                        "in": "query",
                        "required": props.required,
                        "schema": {
                            "type": props.type,
                            "format": props.format,
                        }
                    });
                })
                openapiJson.paths['/'+docName][method].parameters = params;

                componentSchemaPath[method+camelDocName+'Response'] = componentSchemaResponse;
                componentSchemaPath[method+camelDocName+'ResponseList'] = {
                    type: 'array', 
                    items: componentSchemaResponse,
                };
                break;
                // NO break;
            case 'post':
            case 'put':
            case 'patch':
                componentSchemaPath[method+camelDocName+'Body'] = componentSchemaBody;
                componentSchemaPath[method+camelDocName+'Response'] = componentSchemaResponse;
                break;
            default:
                break;
        };
    });

    openapiJson.components.schemas = Object.assign(openapiJson.components.schemas, componentSchemaPath);
    return openapiJson;
}

export default compile;