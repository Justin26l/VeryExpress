import json2openapi from "json-schema-to-openapi-schema";
import yaml from "js-yaml";
import fs from "fs";

import * as types from './types/types';
import * as openapiType from './types/openapi';

export function compile(schemaDir: string, outDir: string) {

    // loop through all json schema files and compile to path object
    let pathObj: { [key: string]: {[key: string]: openapiType.method} } = {};
    
    const files = fs.readdirSync(schemaDir);

    files.forEach((file) => {
        const jsonSchemaPath = `${schemaDir}/${file}`;
        const jsonSchemaBuffer = fs.readFileSync(jsonSchemaPath);
        const jsonSchema = JSON.parse(jsonSchemaBuffer.toString());
        const path = jsonSchema["x-documentConfig"].documentName;
        pathObj = Object.assign(pathObj, jsonToOpenapiPath(path, jsonSchema));
    });

    const openapiJson = {
        openapi: "3.0.0",
        info: {
            title: "veryExpress generated api server",
            description: "OpenApi Spec generated by veryExpress",
            version: "1.0.0"
        },
        paths: pathObj,
        components: {
            schema:{}
        }
    };

    const validOpenApi = json2openapi(openapiJson, { version: 3.0 });
    const openapiYaml = yaml.dump(validOpenApi);

    // create and write file
    const outputPath = `${outDir}/openapi.yaml`;
    fs.writeFileSync(outputPath, openapiYaml);
};

export function jsonToOpenapiPath(
    path: string,
    jsonSchema: types.jsonSchema,
): {
    [key: string]: { // routeName
        [key: string]: openapiType.method; // method
    };
} {
    const documentConfig = jsonSchema["x-documentConfig"];
    const properties = jsonSchema.properties;
    const methods = documentConfig.method;
    const routes: {
        [key: string]: { // route name
            [key: string]: openapiType.method 
        }
    } = {};

    routes['/'+path] = {};
    routes['/'+path+'/{id}'] = {};

    methods.forEach((method) => {
        const useId :boolean = ['put', 'patch', 'delete'].includes(method)
        const useBody :boolean = ['post', 'put', 'patch'].includes(method)
        const route :string = '/'+path + ( useId ?'/{id}' : '');

        routes[route][method] = {
            summary: `${method} ${documentConfig.documentName}`,
            operationId: method + path,
            tags: [path],
            parameters: [],
            requestBody: ! useBody ? undefined : {
                description: `${method} ${documentConfig.documentName}`,
                required: false,
                content: {
                    'application/json': { schema: { $ref: `#/components/schemas/${method}${path}` } },
                },
            },
            responses: {
                200: {
                    description: 'OK',
                    content: { 
                        'application/json': { schema: {} } 
                    },
                },
                201: {
                    description: 'Created',
                    content: { 
                        'application/json': { schema: {} } 
                    },
                },
                400: { description: 'Bad Request', },
                401: { description: 'Unauthorized', },
                403: { description: 'Forbidden', },
                404: { description: 'Not Found', },
                405: { description: 'Method Not Allowed', },
                413: { description: 'Payload Too Large', },
                429: { description: 'Too Many Requests', },
                500: { description: 'Internal Server Error', },
                502: { description: 'Bad Gateway', },
                503: { description: 'Service Unavailable', },
            },
        };

        if (method == 'post') {
            delete routes[route][method].responses[200];
        }
        else {
            delete routes[route][method].responses[201];
        };

        // add query parameters
        if (method == 'get') {

            Object.keys(properties).forEach((key) => {
                const property = properties[key];

                // add id in path
                if(useId && key == '_id') {
                    routes[route][method].parameters.push({
                        name: key,
                        in: 'path',
                        description: property.description,
                        required: true,
                        schema: {
                            type: property.type,
                            format: property.format,
                        },
                    });
                }


                if (property.index) {
                    routes[route][method].parameters.push({
                        name: key,
                        in: 'query',
                        description: property.description,
                        required: property.required,
                        // deprecated: false,
                        // allowEmptyValue: false,
                        // style: 'form',
                        // explode: false,
                        // allowReserved: false,
                        schema: {
                            type: property.type,
                            format: property.format,
                        },
                        // example: property.example,
                        // examples: property.examples,
                    });
                };

            });
        }

    });

    return routes;

};

export default compile;