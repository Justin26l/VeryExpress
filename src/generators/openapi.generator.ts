import json2openapi from "json-schema-to-openapi-schema";
import yaml from "js-yaml";
import fs from "fs";

import * as types from '../types/types';
import * as openapiType from '../types/openapi';
import utils from "../utils/common";
import log from "../utils/log";

/**
 * compile json schema to openapi spec
 * @param schemaDir 
 * @param openapiOutDir 
 */
export function compile(schemaDir: string, outPath: string) :void {

    // convert to yaml
    let openapiJson : openapiType.openapi = {
        openapi: "3.0.0",
        info: {
            title: "veryExpress generated api server",
            description: "OpenApi Spec generated by veryExpress",
            version: "1.0.0"
        },
        paths: {},
        components: {
            schemas: {},
        },
    };
        
    // loop through all json schema files and compile to openapi paths & components

    const files = fs.readdirSync(schemaDir);
    files.forEach((file) => {
        // ignore non json files
        if(!file.endsWith('.json')) return;
        log.process(`OpenApi : ${schemaDir+'/'+file}`);
        
        const jsonSchemaBuffer = fs.readFileSync(`${schemaDir}/${file}`);
        const jsonSchema :types.jsonSchema = JSON.parse(jsonSchemaBuffer.toString());
        openapiJson = jsonToOpenapiPath(openapiJson, jsonSchema);
        openapiJson = jsonToOpenapiComponentSchema(openapiJson, jsonSchema);
    });

    const validOpenApi = json2openapi(openapiJson, { version: 3.0 });
    const openapiYaml = yaml.dump(validOpenApi);

    // create and write file

    log.writing(`OpenApi : ${outPath}`);

    fs.writeFileSync(outPath, openapiYaml);
};

function jsonToOpenapiPath(
    openapiJson: openapiType.openapi,
    jsonSchema: types.jsonSchema,
): openapiType.openapi
{
    // get jsonschema properties
    const documentConfig : types.documentConfig = jsonSchema["x-documentConfig"];
    const lowerDocName : string= documentConfig.documentName.toLowerCase();
    const interfaceName : string= documentConfig.interfaceName;

    const properties :types.jsonSchema['properties'] = jsonSchema.properties;
    const methods: types.method[] = documentConfig.methods;

    let routes: openapiType.paths = {
        ['/'+lowerDocName]: {
            summary: interfaceName,
        },
        ['/'+lowerDocName+'/{id}']: {
            summary: interfaceName,
        },
    };

    methods.forEach((method) => {
        const useId :boolean = [types.method.put, types.method.patch, types.method.delete].includes(method);
        const useBody :boolean = [types.method.post, types.method.put, types.method.patch].includes(method);
        const route :string = '/'+lowerDocName + ( useId ?'/{id}' : '');

        routes[route][method] = {
            summary: interfaceName,
            operationId: method + interfaceName,
            tags: [lowerDocName],
            parameters: [],
            requestBody: undefined,
            responses: {
                200: {
                    description: 'OK',
                    content: { 
                        'application/json': { schema: { $ref: `#/components/schemas/${method}${interfaceName}Response` } },
                    },
                },
                400: { description: 'Bad Request', },
                401: { description: 'Unauthorized', },
                403: { description: 'Forbidden', },
                404: { description: 'Not Found', },
                405: { description: 'Method Not Allowed', },
                413: { description: 'Payload Too Large', },
                429: { description: 'Too Many Requests', },
                500: { description: 'Internal Server Error', },
                502: { description: 'Bad Gateway', },
                503: { description: 'Service Unavailable', },
            },
        };

        // update parameters/body & responses

        if( (useId || method == types.method.get) && properties['_id']){
            const idParameter : openapiType.parameter = {
                name: 'id',
                in: 'path',
                description: properties['_id'].description,
                required: true,
                schema: { 
                    type: properties['_id'].type, 
                    format: properties['_id'].format,
                },
            };

            routes[route][method]!.parameters = [idParameter];

            // GET will have additional route of GET /{id}
            if(method == types.method.get){
                routes[route+'/{id}'][method] = routes[route][method];

                // god of defining types, please help me fuck this mf asshole
                // @ts-ignore
                routes[route+'/{id}'][method].responses[200].content["application/json"].schema.$ref = `#/components/schemas/${method}${interfaceName}Response`;
                
                routes[route+'/{id}'][method]!.parameters = [idParameter];
            };
        };

        if(useBody){
            routes[route][method]!.requestBody = {
                description: `${method} ${documentConfig.documentName}`,
                required: false,
                content: {
                    'application/json': { schema: { $ref: `#/components/schemas/${method}${interfaceName}Body` } },
                },
            };
        };

        // POST will use 201 success response
        if (method == types.method.post) {
            routes[route][method]!.responses[201] = routes[route][method]!.responses[200];
            routes[route][method]!.responses[201].description = 'Crerated';
            delete routes[route][method]!.responses[200];
        }
        else if (method == types.method.delete) {
            delete routes[route][method]!.responses[200].content;
        };

    });

    openapiJson.paths = Object.assign(openapiJson.paths, routes);
    return openapiJson;
};

function jsonToOpenapiComponentSchema(
    openapiJson: openapiType.openapi,
    jsonSchema: types.jsonSchema,
): openapiType.openapi
{
    let parameters: openapiType.parameter[] = [];
    let componentSchemaPath: openapiType.components['schemas'] = {};

    // get jsonschema properties
    const documentConfig = jsonSchema["x-documentConfig"];
    const lowerDocName = documentConfig.documentName.toLowerCase();
    const interfaceName = documentConfig.interfaceName;
    const methods: types.method[] = documentConfig.methods;

    const componentSchemaResponse : openapiType.componentsSchemaValue = {
        type: 'object',
        properties: json2openapi(
            utils.cleanXcustomValue(jsonSchema.properties, ['index', 'unique', 'required']), 
            { version: 3.0 }
        ),
    };
    
    const componentSchemaBody : openapiType.componentsSchemaValue = {
        type: 'object',
        properties: json2openapi(
            utils.cleanXcustomValue(jsonSchema.properties, ['_id', 'index', 'unique', 'required']), 
            { version: 3.0 }
        ),
    };


    methods.forEach((method) => {
        switch (method) {
            case types.method.delete:
                // no param, no response
                break;
            case types.method.get:
                let parameters : openapiType.parameter[] = [];
                Object.keys(jsonSchema.properties).forEach((key)=>{
                    const props = jsonSchema.properties[key];
                    
                    // skip object, it should not be in query
                    if(props.type == 'object') return;

                    let parameter : openapiType.parameter ={
                        name: key,
                        in: "query",
                        required: props.required,
                        schema: {
                            type: props.type,
                            format: props.format,
                            minLength: props.minLength,
                            maxLength: props.maxLength,
                            minimum: props.minimum,
                            maximum: props.maximum,
                            enum: props.enum,
                        }
                    };
                    parameters.push(parameter);
                });

                openapiJson.paths['/' + lowerDocName][method]!.parameters = parameters;

                componentSchemaPath[method + interfaceName + 'Response'] = componentSchemaResponse;
                componentSchemaPath[method+interfaceName+'ResponseList'] = {
                    type: 'array', 
                    items: componentSchemaResponse,
                };
                break;
                // NO break;
            case types.method.post:
            case types.method.put:
            case types.method.patch:
                componentSchemaPath[method+interfaceName+'Body'] = componentSchemaBody;
                componentSchemaPath[method+interfaceName+'Response'] = componentSchemaResponse;
                break;
            default:
                break;
        };
    });

    openapiJson.components.schemas = Object.assign(openapiJson.components.schemas, componentSchemaPath);
    return openapiJson;
}

export default compile;